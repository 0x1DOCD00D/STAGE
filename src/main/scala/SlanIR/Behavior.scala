/*
 * Copyright (c) 2022. Mark Grechanik and Lone Star Consulting, Inc. All rights reserved.
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 *  License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 *  See the License for the specific language governing permissions and limitations under the License.
 */

package SlanIR

import HelperUtils.ErrorWarningMessages.{DuplicateDefinition, EmptyWarning, MissingDefinition}

trait SlanExpression
trait SlanRelationalExpression extends SlanExpression
case class SlanIfThenElse(ifCondition: SlanRelationalExpression, thenExp: List[SlanExpression], elseExp: List[SlanExpression]) extends SlanExpression

case class AND(subExpressions: List[SlanExpression]) extends SlanRelationalExpression
case class OR(subExpressions: List[SlanExpression]) extends SlanRelationalExpression
case class XOR(subExpressions: List[SlanExpression]) extends SlanRelationalExpression
case class NOT(expression: SlanExpression) extends SlanRelationalExpression

case class LESS(left: SlanExpression, right: SlanExpression) extends SlanRelationalExpression
case class LESSOREQUAL(left: SlanExpression, right: SlanExpression) extends SlanRelationalExpression
case class EQUAL(left: SlanExpression, right: SlanExpression) extends SlanRelationalExpression
case class GREATER(left: SlanExpression, right: SlanExpression) extends SlanRelationalExpression
case class GREATEROREQUAL(left: SlanExpression, right: SlanExpression) extends SlanRelationalExpression
case class NOTEQUAL(left: SlanExpression, right: SlanExpression) extends SlanRelationalExpression

case class Correlation(id: CorrelationId) extends SlanEntity(id) with SlanExpression

trait SlanFunction extends SlanExpression
/*
* The function Fn_Update is based on the destructive assignment expression in imperative languages where the
* value held by a resource is updated. If the resource is a storage-based entity then the value is stored,
* o/w the previously held value is overwritten by a new one computed by some computation passed in the
* second parameter of the function. All stored values are of the type long and these values can reference
* specific SLAN entities or some simulated activities.
* */
case class Fn_Update(updatedResource: ResourceIR, computation: List[SlanExpression]) extends SlanFunction
/*
* Given a resource designated by the parameter structure4Removal specify what values should be removed
* from this resource. If None is specified then remove the first value from the storage, otherwise
* compute the values using the list of expressions and remove them from the storage.
* */
case class Fn_Remove(structure4Removal: ResourceIR, specificValues2remove: Option[List[SlanExpression]]) extends SlanFunction

/*
* Create Agents or Messages on demand. It takes a generator resource as its input parameter that produces
* a stream of lists where each list contains tuples whose first element designates SlanEntity to generate and
* the second element specifies the number of these SlanEntities to generate. Output the list of created entities.
* */
case class Fn_Create(generator: Generator | List[(MessageIR, Long)] | List[(Agent, Long)]) extends SlanFunction
/*
* The specified entity is destroyed, e.g., an agent is removed from the simulation. Returns the id of tne
* destroyed entity.
* */
case class Fn_Destroy(entity: Agent) extends SlanFunction

/*
* Sending messages is done by placing the messages specified in the input parameter list
* in channels attached to the agent whose behaviors invoke this function, Fn_Send.
* This list may be generated by using some generator resource. Output the number of sent messages.
* */
case class Fn_Send(messages2Send: List[(MessageIR, Long)] | MessageIR | Generator) extends SlanFunction

/*
* Given some designator of a collection, e.g., members of a group, all stored values in a resource,
* or all messages produced by some generator resource, perform a sequence of computation expressions
* on each element of this collection and output the number of processed elements.
* */
case class Fn_ForEach(collection: SlanEntity, computation: List[SlanExpression]) extends SlanFunction

/*
* Adepts can provide external modules implemented as jars or restful endpoints or potentially an arbitrary network-bound
* endpoint that is defined by some protocol. This external endpoint is viewed as a method with some parameters and both
* the method and its parameters are described using Resources. Input values for the method parameters are defined in
* the Resource attributes that should match the types of the parameters if they are containers. Recall that there is only
* one basic type in simulations - Long and its values represent all objects defined in simulations. Container types are
* defined using type constructors where the parameter type is either a container or Long. So if a method takes three
* parameters: list, map and long then the corresponding resource must contain three attributes of these types.
* */
case class Fn_Invoke(endpoint: ResourceIR, parameters: ResourceIR) extends SlanFunction

/*
* Agents can join or leave a group dynamically based on some logic implemented
* as part of the behavior. Each group keeps a track of its members.
* */
case class Fn_Join(group: Group, agents: List[Agent]) extends SlanFunction
case class Fn_Leave(group: Group, agents: List[Agent]) extends SlanFunction

/*
* These are arithmetic expression functions that return the result of the arithmetic operation.
* Add and Mult functions take multiple operands whereas Sub and Div take only two and Inc and Dec take one.
* */
case class Fn_Add(operands: SlanExpression*)
case class Fn_Mult(operands: SlanExpression*)
case class Fn_Inc(operand: SlanExpression)
case class Fn_Dec(operand: SlanExpression)
case class Fn_Sub(operand1: SlanExpression, operand2: SlanExpression)
case class Fn_Div(operand1: SlanExpression, operand2: SlanExpression)

case class Behavior(id: EntityId, messagesResponses: List[(MessageIR, List[SlanExpression])]) extends SlanEntity(id)

object Behavior:
  private val bookkeeper = new EntityBookkeeper[Behavior]
  def apply(id: EntityId): Option[Behavior] = bookkeeper.get(id)
/*

  def apply(id: EntityId, triggeredByMsgs: List[(Message, List[SlanExpression])]): EntityOrError[Behavior] =
    if bookkeeper.contains(id) then
      DuplicateDefinition(s"behavior $id")
    else if triggeredByMsgs.isEmpty then
      EmptyWarning(s"behavior $id is not defined")
    else
      bookkeeper.set(id, Behavior(id, triggeredByMsgs))
*/
